# Phase 10 — Tests

## Goal

Comprehensive test suite covering unit, integration, and E2E tests. Target: 80%+ code coverage.

## Prerequisites

- Phases 02-08 complete (all source code exists)

## Note

Many tests should have been written during earlier phases (each phase guide includes test requirements). This phase ensures complete coverage, adds missing tests, and creates the full E2E suite.

---

## Step 1: Create test fixture

The fixture is a complete mini-project with a yggdrasil graph AND source code files (for drift testing).

### `tests/fixtures/sample-project/yggdrasil/config.yaml`

```yaml
name: "Sample E-Commerce"

stack:
  language: TypeScript
  runtime: Node 22
  framework: NestJS
  database: PostgreSQL

standards:
  coding: |
    Clean Architecture pattern.
    camelCase for functions, PascalCase for classes.
  testing: |
    Jest as test framework.
    Co-locate test files with source.

limits:
  context_warning_tokens: 8000

tags:
  requires-auth:
    description: "Requires authenticated user"
    propagates: false
  requires-audit:
    description: "Operations must be logged"
    propagates: true
  public-api:
    description: "Public-facing endpoint"
    propagates: false
  server-only:
    description: "Server-side only"
    propagates: false
    conflicts_with: [client-interactive]
  client-interactive:
    description: "Client-side interactive"
    propagates: false
    conflicts_with: [server-only]
```

### `tests/fixtures/sample-project/yggdrasil/aspects/audit-logging.yaml`

```yaml
name: Audit Logging
tag: requires-audit
description: |
  Every data-modifying operation must be logged to the audit_log table.
requirements:
  - "Use AuditService.log() for all create, update, delete"
  - "Never log sensitive fields"
```

### `tests/fixtures/sample-project/yggdrasil/flows/checkout-flow/flow.yaml`

```yaml
name: Checkout Flow
nodes:
  - orders/order-service
```

### `tests/fixtures/sample-project/yggdrasil/flows/checkout-flow/sequence.md`

```markdown
# Checkout Sequence
Cart -> OrderService -> PaymentService -> Confirmation
```

### Node fixtures:

Create directories with node.yaml and artifacts for:

- `auth/` — type: module, tags: [requires-audit]
  - `auth/login-service/` — type: service, relations: [users/user-repo], mapping: src/auth/login.service.ts
  - `auth/auth-api/` — type: interface, tags: [public-api], mapping: src/auth/auth.controller.ts
- `orders/` — type: module, tags: [requires-audit]
  - `orders/order-service/` — type: service, tags: [requires-auth], relations: [auth/auth-api], mapping: src/orders/order.service.ts
- `users/` — type: module
  - `users/user-repo/` — type: service, mapping: src/users/user.repository.ts

### Source code fixtures (for drift testing):

Create minimal TypeScript files at the mapping paths:
- `tests/fixtures/sample-project/src/auth/login.service.ts`
- `tests/fixtures/sample-project/src/auth/auth.controller.ts`
- `tests/fixtures/sample-project/src/orders/order.service.ts`
- `tests/fixtures/sample-project/src/users/user.repository.ts`

Each file just needs a simple class export:
```typescript
export class LoginService {
  // Generated by Yggdrasil
}
```

### Drift state fixture:

Create `tests/fixtures/sample-project/yggdrasil/.drift-state` with hashes matching SOME files (to test OK, DRIFT, and UNMATERIALIZED states).

---

## Step 2: Unit tests

Create in `tests/unit/`:

### `tests/unit/io/`
- `config-parser.test.ts` — valid parse, missing name, defaults
- `node-parser.test.ts` — valid parse, missing fields, mapping normalization
- `aspect-parser.test.ts` — valid parse, missing fields
- `flow-parser.test.ts` — valid parse with artifacts
- `artifact-reader.test.ts` — reads files, excludes binaries, excludes node.yaml
- `drift-state-store.test.ts` — read existing, read missing (defaults), write

### `tests/unit/core/`
- `graph-loader.test.ts` — loads fixture, correct node count, parent-child, aspects, flows
- `context-builder.test.ts` — all 6 layers, tag propagation, broken relations
- `dependency-resolver.test.ts` — linear chain, diamond, parallel, cycles, blackbox exclusion
- `validator.test.ts` — one test per rule (positive + negative)
- `drift-detector.test.ts` — ok, drift, missing, unmaterialized, absorb

### `tests/unit/utils/`
- `hash.test.ts` — deterministic hash
- `paths.test.ts` — normalizeMappingPaths, toGraphPath, findYggRoot
- `tokens.test.ts` — returns a number > 0

---

## Step 3: Integration tests

Create in `tests/integration/`:

### `context-pipeline.test.ts`
Full pipeline: loadGraph → buildContext → formatMarkdown
- Load fixture graph
- Build context for `orders/order-service`
- Verify output contains all 6 layers
- Verify global context has stack info
- Verify hierarchy includes orders/ artifacts
- Verify own artifacts present
- Verify relational includes auth-api artifacts
- Verify audit aspect included (tag propagation from parent)
- Verify checkout flow artifacts included

### `validation-pipeline.test.ts`
- Load fixture graph → validate → 0 issues
- Modify fixture to introduce errors → validate → correct issues found

### `drift-pipeline.test.ts`
- Load fixture graph → detect drift → verify correct states per node

---

## Step 4: E2E tests

Create in `tests/e2e/`:

Test the actual CLI binary as a subprocess. Use `execa` or Node's `child_process.execFile`.

```typescript
import { execFile } from 'node:child_process';
import path from 'node:path';

const CLI = path.resolve('dist/bin.js');
const FIXTURE = path.resolve('tests/fixtures/sample-project');

function run(args: string[]): Promise<{ stdout: string; stderr: string; exitCode: number }> {
  return new Promise((resolve) => {
    execFile('node', [CLI, ...args], { cwd: FIXTURE }, (error, stdout, stderr) => {
      resolve({
        stdout: stdout.toString(),
        stderr: stderr.toString(),
        exitCode: error?.code ?? 0,
      });
    });
  });
}
```

### Tests:

```typescript
test('ygg --version', async () => {
  const { stdout } = await run(['--version']);
  expect(stdout.trim()).toBe('0.1.0');
});

test('ygg tree', async () => {
  const { stdout, exitCode } = await run(['tree']);
  expect(exitCode).toBe(0);
  expect(stdout).toContain('auth/');
  expect(stdout).toContain('orders/');
});

test('ygg check on valid graph', async () => {
  const { exitCode } = await run(['check']);
  expect(exitCode).toBe(0);
});

test('ygg build-context', async () => {
  const { stdout, exitCode } = await run(['build-context', 'orders/order-service']);
  expect(exitCode).toBe(0);
  expect(stdout).toContain('Context Package: OrderService');
  expect(stdout).toContain('Global Context');
  expect(stdout).toContain('Node: OrderService');
});

test('ygg build-context --format json', async () => {
  const { stdout } = await run(['build-context', 'orders/order-service', '--format', 'json']);
  const pkg = JSON.parse(stdout);
  expect(pkg.nodeName).toBe('OrderService');
  expect(pkg.layers.length).toBeGreaterThan(0);
});

test('ygg build-context nonexistent node', async () => {
  const { exitCode } = await run(['build-context', 'does/not/exist']);
  expect(exitCode).toBe(1);
});

test('ygg resolve-deps', async () => {
  const { stdout, exitCode } = await run(['resolve-deps']);
  expect(exitCode).toBe(0);
  expect(stdout).toContain('Stage');
});

test('ygg affected', async () => {
  const { stdout } = await run(['affected', 'auth/auth-api']);
  expect(stdout).toContain('orders/order-service');
});

test('ygg status', async () => {
  const { stdout } = await run(['status']);
  expect(stdout).toContain('Sample E-Commerce');
  expect(stdout).toContain('Nodes:');
});

test('ygg drift', async () => {
  const { stdout } = await run(['drift']);
  expect(stdout).toContain('nodes checked');
});
```

---

## Step 5: Run coverage

```bash
npm run test:coverage
```

Check that coverage is 80%+ for `src/core/`, `src/io/`, `src/utils/`.

---

## Verification

```bash
cd source/cli
npm test                    # all tests pass
npm run test:coverage       # 80%+ coverage
npm run build               # build still works
```

## Acceptance Criteria

- [ ] Test fixture exists with complete mini-graph
- [ ] Unit tests cover all parsers, core modules, and utils
- [ ] Integration tests cover full pipelines (context, validation, drift)
- [ ] E2E tests cover all 8 CLI commands
- [ ] Coverage is 80%+ for core code
- [ ] All tests pass in CI (GitHub Actions)
